<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ONNX Inference Example</title>

    <!-- Load ONNX Runtime with updated version -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.16.0/dist/ort.min.js"></script>
    
    <!-- Fallback script with updated version -->
    <script>
        window.addEventListener('DOMContentLoaded', function() {
            setTimeout(function() {
                if (typeof ort === 'undefined') {
                    console.log('Trying alternative ONNX Runtime source...');
                    var script = document.createElement('script');
                    script.src = 'https://unpkg.com/onnxruntime-web@1.16.0/dist/ort.min.js';
                    script.onload = function() {
                        console.log('Alternative ONNX Runtime loaded');
                        if (typeof ort !== 'undefined') {
                            initializeApp();
                        }
                    };
                    document.head.appendChild(script);
                }
            }, 2000);
        });
    </script>
</head>
<body>
    <div class="container">
        <h1>Emotion Detection Demo</h1>
        <div class="status-message" id="onnxStatus">Loading ONNX Runtime...</div>
        <div class="input-section">
            <textarea id="inputText" rows="4" cols="50" placeholder="Enter text to analyze...">This is a test sentence.</textarea>
            <button id="analyzeBtn" disabled>Analyze</button>
        </div>
        <div class="model-section">
            <p>Model not loaded yet. Make sure your ONNX file is accessible at the correct URL.</p>
            <p>Current model URL: <code id="modelUrlDisplay">emotion_model.onnx</code> <button id="editModelUrl">Edit URL</button></p>
        </div>
        <div class="results-section">
            <h2>Results:</h2>
            <div id="output">Please enter text and click Analyze.</div>
            <div id="spinner" class="spinner" style="display: none;">Processing...</div>
        </div>
    </div>

    <script>
        // Global variables
        const maxLength = 128;
        const emotionLabels = [
            "joy", "sadness", "anger", "fear", "surprise", "disgust", "neutral"
        ];
        let modelUrl = 'emotion_model.onnx'; // Default model URL
        
        // Simple vocabulary for tokenization - this should match your model's vocabulary
        // Note: In a real application, you would use the same tokenizer used during training
        const vocabulary = {
            "[PAD]": 0,
            "[UNK]": 1,
            "this": 2,
            "is": 3,
            "a": 4,
            "test": 5,
            "sentence": 6,
            // Add more tokens as needed for your specific model
        };

        // Wait for ONNX Runtime to be fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Check if ort is available after a short delay to ensure it's loaded
            setTimeout(() => {
                if (typeof ort !== 'undefined') {
                    console.log('ONNX Runtime loaded successfully');
                    initializeApp();
                } else {
                    console.error('ONNX Runtime failed to load');
                    document.getElementById('onnxStatus').textContent = 
                        'Error: ONNX Runtime not loaded. Please check your internet connection and try again.';
                    document.getElementById('onnxStatus').classList.add('error');
                    document.getElementById('output').textContent = 
                        'ONNX Runtime failed to load. Please refresh the page or try another browser.';
                }
            }, 1000);

            // Add listener for editing model URL
            document.getElementById('editModelUrl').addEventListener('click', function() {
                const newUrl = prompt('Enter the URL or path to your ONNX model:', modelUrl);
                if (newUrl && newUrl.trim() !== '') {
                    modelUrl = newUrl.trim();
                    document.getElementById('modelUrlDisplay').textContent = modelUrl;
                    document.getElementById('output').textContent = 'Model URL updated. Click Analyze to test with the new model.';
                }
            });
        });

        // Initialize the application
        function initializeApp() {
            // Enable the analyze button and update status
            document.getElementById('analyzeBtn').disabled = false;
            document.getElementById('onnxStatus').textContent = 'ONNX Runtime loaded successfully';
            document.getElementById('onnxStatus').classList.add('success');
            
            document.getElementById('analyzeBtn').addEventListener('click', function() {
                const text = document.getElementById('inputText').value;
                if (text.trim() === '') {
                    alert('Please enter some text to analyze');
                    return;
                }
                
                document.getElementById('spinner').style.display = 'block';
                document.getElementById('output').textContent = 'Analyzing...';
                
                runInference(text)
                    .catch(error => {
                        console.error('Error:', error);
                        document.getElementById('output').textContent = 'Error: ' + error.message;
                    })
                    .finally(() => {
                        document.getElementById('spinner').style.display = 'none';
                    });
            });
        }

        async function runInference(text) {
            // Check if ONNX Runtime is available
            if (typeof ort === 'undefined') {
                const errorMsg = 'ONNX Runtime not loaded. Please refresh the page and try again.';
                document.getElementById('output').textContent = 'Error: ' + errorMsg;
                throw new Error(errorMsg);
            }

            try {
                // Display loading status
                document.getElementById('output').textContent = 'Loading model...';
                
                // Set WebAssembly execution provider options
                const options = {
                    executionProviders: ['wasm'],
                    graphOptimizationLevel: 'all',
                    enableCpuMemArena: true,
                    logSeverityLevel: 0,
                };
                
                // Initialize session with try-catch and timeout
                let sessionPromise = new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        reject(new Error('Loading model timed out after 30 seconds'));
                    }, 30000);
                    
                    ort.InferenceSession.create(modelUrl, options)
                        .then(session => {
                            clearTimeout(timeout);
                            resolve(session);
                        })
                        .catch(err => {
                            clearTimeout(timeout);
                            reject(err);
                        });
                });
                
                const session = await sessionPromise;
                
                // Update status
                document.getElementById('output').textContent = 'Processing text...';
                
                // Log model input and output information
                console.log('Model inputs:', session.inputNames);
                console.log('Model outputs:', session.outputNames);
                
                // 2. Preprocess the input text
                const inputData = preprocess(text);
                
                // 3. Run the inference
                const feeds = {};
                feeds[session.inputNames[0]] = inputData.inputTensor;
                
                // If the model requires attention mask and it's in the input names
                if (session.inputNames.length > 1 && session.inputNames[1].includes('attention') || 
                    session.inputNames[1] === 'mask' || session.inputNames[1] === 'attention_mask') {
                    feeds[session.inputNames[1]] = inputData.attentionMask;
                }
                
                const results = await session.run(feeds);
                
                // 4. Postprocess the output
                const prediction = postprocess(results, session.outputNames[0]);
                
                // Display results
                const resultElement = document.getElementById('output');
                resultElement.innerHTML = `
                    <div class="prediction-result">
                        <p><strong>Detected emotion:</strong> ${prediction.label}</p>
                        <p><strong>Confidence:</strong> ${(prediction.confidence * 100).toFixed(2)}%</p>
                        <h3>All Emotions:</h3>
                        <ul>
                            ${prediction.allProbabilities.map((prob, idx) => {
                                const label = idx < prediction.allLabels.length ? 
                                    prediction.allLabels[idx] : `Class ${idx}`;
                                return `<li>${label}: ${(prob * 100).toFixed(2)}%</li>`;
                            }).join('')}
                        </ul>
                    </div>
                `;
                
                return prediction;
            } catch (error) {
                console.error('Error during inference:', error);
                
                // Provide more helpful error messages based on common problems
                let errorMessage = error.message;
                if (error.message.includes('protobuf parsing failed')) {
                    errorMessage = 'Invalid ONNX model format or model file not accessible. Please check if the model URL is correct and the model is properly formatted. Make sure your model is accessible via the current domain (CORS policy).';
                } else if (error.message.includes('Can\'t create a session')) {
                    errorMessage = 'Failed to initialize ONNX session. This may be due to an incompatible model format, insufficient memory, or browser limitations. Try a smaller model or checking browser console for specific errors.';
                }
                
                document.getElementById('output').innerHTML = `
                    <div class="error-message">
                        <p><strong>Error:</strong> ${errorMessage}</p>
                        <p>Troubleshooting tips:</p>
                        <ul>
                            <li>Check if the model URL is correct</li>
                            <li>Ensure the model is accessible from this domain (CORS issues)</li>
                            <li>Verify the model format is compatible with ONNX Runtime Web</li>
                            <li>Try using a smaller or simpler model</li>
                            <li>Check browser console for additional error details</li>
                        </ul>
                    </div>
                `;
                throw new Error(errorMessage);
            }
        }

        function preprocess(text) {
            console.log('Preprocessing text:', text);
            
            // Simple tokenization (split by space and convert to lowercase)
            const tokens = text.toLowerCase().split(/\s+/).slice(0, maxLength);
            
            // Convert tokens to ids using the vocabulary
            const inputIds = tokens.map(token => {
                return vocabulary[token] !== undefined ? vocabulary[token] : vocabulary["[UNK]"];
            });
            
            // Pad or truncate to maxLength
            const paddedIds = inputIds.length >= maxLength 
                ? inputIds.slice(0, maxLength) 
                : [...inputIds, ...Array(maxLength - inputIds.length).fill(vocabulary["[PAD]"])];
            
            // Create attention mask (1 for actual tokens, 0 for padding)
            const attentionMask = inputIds.length >= maxLength
                ? Array(maxLength).fill(1)
                : [...Array(inputIds.length).fill(1), ...Array(maxLength - inputIds.length).fill(0)];
            
            console.log('Input tensor shape:', [1, maxLength]);
            console.log('First few values:', paddedIds.slice(0, 5));
            
            // Create input tensors - safeguarding against errors
            let inputTensor, attentionMaskTensor;
            
            try {
                // Try first with int64 type (common for transformers)
                inputTensor = new ort.Tensor('int64', new BigInt64Array(paddedIds.map(x => BigInt(x))), [1, maxLength]);
                attentionMaskTensor = new ort.Tensor('int64', new BigInt64Array(attentionMask.map(x => BigInt(x))), [1, maxLength]);
            } catch (err) {
                console.warn('Failed to create int64 tensors, falling back to int32:', err);
                // Fall back to int32 (for models that expect int32 inputs)
                inputTensor = new ort.Tensor('int32', new Int32Array(paddedIds), [1, maxLength]);
                attentionMaskTensor = new ort.Tensor('int32', new Int32Array(attentionMask), [1, maxLength]);
            }
            
            return {
                inputTensor: inputTensor,
                attentionMask: attentionMaskTensor
            };
        }

        function postprocess(results, outputName) {
            console.log('Model outputs:', results);
            console.log('Output names:', Object.keys(results));
            
            // Get the output tensor
            let outputTensor = results[outputName];
            if (!outputTensor) {
                console.error('Output tensor not found:', outputName);
                // Try the first output if the specified one isn't found
                const firstOutputName = Object.keys(results)[0];
                console.log('Using first available output instead:', firstOutputName);
                outputTensor = results[firstOutputName];
            }
            
            // Extract data from the tensor
            const outputData = outputTensor.data;
            const outputShape = outputTensor.dims;
            
            console.log('Output shape:', outputShape);
            console.log('Output data:', Array.from(outputData).slice(0, 10));
            
            // Find the index with the highest probability
            let maxIndex = 0;
            let maxValue = outputData[0];
            
            for (let i = 1; i < outputData.length; i++) {
                if (outputData[i] > maxValue) {
                    maxValue = outputData[i];
                    maxIndex = i;
                }
            }
            
            // Apply softmax if needed to get probabilities
            const expValues = Array.from(outputData).map(val => Math.exp(val));
            const sumExp = expValues.reduce((acc, val) => acc + val, 0);
            const probabilities = expValues.map(val => val / sumExp);
            
            // Get the label for the prediction
            const predictedLabel = maxIndex < emotionLabels.length 
                ? emotionLabels[maxIndex] 
                : `Class ${maxIndex}`;
            
            return {
                label: predictedLabel,
                confidence: probabilities[maxIndex],
                allProbabilities: probabilities,
                allLabels: emotionLabels
            };
        }
    </script>

    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            text-align: center;
        }
        
        .input-section, .model-section {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 4px;
            border: 1px solid #eee;
        }
        
        textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 10px;
            font-family: inherit;
        }
        
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            text-align: center;
            cursor: pointer;
            border-radius: 4px;
            font-size: 16px;
        }
        
        #editModelUrl {
            background-color: #2196F3;
            padding: 5px 10px;
            font-size: 14px;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        button:hover:not(:disabled) {
            background-color: #45a049;
        }
        
        #editModelUrl:hover:not(:disabled) {
            background-color: #0b7dda;
        }
        
        .results-section {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #eee;
        }
        
        .prediction-result {
            margin-top: 10px;
        }
        
        .spinner {
            color: #666;
            font-style: italic;
        }
        
        .status-message {
            padding: 8px;
            margin: 10px 0;
            border-radius: 4px;
            text-align: center;
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
        }
        
        .status-message.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status-message.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .error-message {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            padding: 15px;
            border-radius: 4px;
        }
        
        code {
            background-color: #f0f0f0;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: monospace;
        }
    </style>
</body>
</html>
