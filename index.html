<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ONNX Inference Example</title>

    <!-- Load ONNX Runtime with alternative CDN source -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.14.0/dist/ort.min.js"></script>
    
    <!-- Fallback script to load from another CDN if the first one fails -->
    <script>
        window.addEventListener('DOMContentLoaded', function() {
            setTimeout(function() {
                if (typeof ort === 'undefined') {
                    console.log('Trying alternative ONNX Runtime source...');
                    var script = document.createElement('script');
                    script.src = 'https://unpkg.com/onnxruntime-web@1.14.0/dist/ort.min.js';
                    script.onload = function() {
                        console.log('Alternative ONNX Runtime loaded');
                        if (typeof ort !== 'undefined') {
                            initializeApp();
                        }
                    };
                    document.head.appendChild(script);
                }
            }, 2000);
        });
    </script>
</head>
<body>
    <div class="container">
        <h1>Emotion Detection Demo</h1>
        <div class="status-message" id="onnxStatus">Loading ONNX Runtime...</div>
        <div class="input-section">
            <textarea id="inputText" rows="4" cols="50" placeholder="Enter text to analyze...">This is a test sentence.</textarea>
            <button id="analyzeBtn" disabled>Analyze</button>
        </div>
        <div class="results-section">
            <h2>Results:</h2>
            <div id="output">Please enter text and click Analyze.</div>
            <div id="spinner" class="spinner" style="display: none;">Processing...</div>
        </div>
    </div>

    <script>
        // Global variables
        const maxLength = 128;
        const emotionLabels = [
            "joy", "sadness", "anger", "fear", "surprise", "disgust", "neutral"
        ];
        
        // Simple vocabulary for tokenization - this should match your model's vocabulary
        // Note: In a real application, you would use the same tokenizer used during training
        const vocabulary = {
            "[PAD]": 0,
            "[UNK]": 1,
            "this": 2,
            "is": 3,
            "a": 4,
            "test": 5,
            "sentence": 6,
            // Add more tokens as needed for your specific model
        };

        // Wait for ONNX Runtime to be fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Check if ort is available after a short delay to ensure it's loaded
            setTimeout(() => {
                if (typeof ort !== 'undefined') {
                    console.log('ONNX Runtime loaded successfully');
                    initializeApp();
                } else {
                    console.error('ONNX Runtime failed to load');
                    document.getElementById('onnxStatus').textContent = 
                        'Error: ONNX Runtime not loaded. Please check your internet connection and try again.';
                    document.getElementById('onnxStatus').classList.add('error');
                    document.getElementById('output').textContent = 
                        'ONNX Runtime failed to load. Please refresh the page or try another browser.';
                }
            }, 1000);
        });

        // Initialize the application
        function initializeApp() {
            // Enable the analyze button and update status
            document.getElementById('analyzeBtn').disabled = false;
            document.getElementById('onnxStatus').textContent = 'ONNX Runtime loaded successfully';
            document.getElementById('onnxStatus').classList.add('success');
            
            document.getElementById('analyzeBtn').addEventListener('click', function() {
                const text = document.getElementById('inputText').value;
                if (text.trim() === '') {
                    alert('Please enter some text to analyze');
                    return;
                }
                
                document.getElementById('spinner').style.display = 'block';
                document.getElementById('output').textContent = 'Analyzing...';
                
                runInference(text)
                    .catch(error => {
                        console.error('Error:', error);
                        document.getElementById('output').textContent = 'Error: ' + error.message;
                    })
                    .finally(() => {
                        document.getElementById('spinner').style.display = 'none';
                    });
            });
        }

        async function runInference(text) {
            // Check if ONNX Runtime is available
            if (typeof ort === 'undefined') {
                const errorMsg = 'ONNX Runtime not loaded. Please refresh the page and try again.';
                document.getElementById('output').textContent = 'Error: ' + errorMsg;
                throw new Error(errorMsg);
            }

            // 1. Load the ONNX model (fetch from a URL)
            const modelUrl = 'emotion_model.onnx';
            try {
                // Display loading status
                document.getElementById('output').textContent = 'Loading model...';
                
                // Create inference session
                const session = await ort.InferenceSession.create(modelUrl);
                
                // Update status
                document.getElementById('output').textContent = 'Processing text...';
                
                // 2. Preprocess the input text
                const inputData = preprocess(text);
                
                // 3. Run the inference
                const feeds = {};
                feeds[session.inputNames[0]] = inputData.inputTensor;
                
                // If the model requires attention mask
                if (session.inputNames.length > 1) {
                    feeds[session.inputNames[1]] = inputData.attentionMask;
                }
                
                // Check input names for debugging
                console.log('Model input names:', session.inputNames);
                
                const results = await session.run(feeds);
                
                // 4. Postprocess the output
                const prediction = postprocess(results, session.outputNames[0]);
                
                // Display results
                const resultElement = document.getElementById('output');
                resultElement.innerHTML = `
                    <div class="prediction-result">
                        <p><strong>Detected emotion:</strong> ${prediction.label}</p>
                        <p><strong>Confidence:</strong> ${(prediction.confidence * 100).toFixed(2)}%</p>
                    </div>
                `;
                
                return prediction;
            } catch (error) {
                console.error('Error during inference:', error);
                document.getElementById('output').textContent = 'Error: ' + error.message;
                throw error;
            }
        }

        function preprocess(text) {
            console.log('Preprocessing text:', text);
            
            // Simple tokenization (split by space and convert to lowercase)
            const tokens = text.toLowerCase().split(/\s+/).slice(0, maxLength);
            
            // Convert tokens to ids using the vocabulary
            const inputIds = tokens.map(token => {
                return vocabulary[token] !== undefined ? vocabulary[token] : vocabulary["[UNK]"];
            });
            
            // Pad or truncate to maxLength
            const paddedIds = inputIds.length >= maxLength 
                ? inputIds.slice(0, maxLength) 
                : [...inputIds, ...Array(maxLength - inputIds.length).fill(vocabulary["[PAD]"])];
            
            // Create attention mask (1 for actual tokens, 0 for padding)
            const attentionMask = inputIds.length >= maxLength
                ? Array(maxLength).fill(1)
                : [...Array(inputIds.length).fill(1), ...Array(maxLength - inputIds.length).fill(0)];
            
            console.log('Input tensor shape:', [1, maxLength]);
            console.log('First few values:', paddedIds.slice(0, 5));
            
            // Create input tensors
            const inputTensor = new ort.Tensor('int64', new BigInt64Array(paddedIds.map(x => BigInt(x))), [1, maxLength]);
            const attentionMaskTensor = new ort.Tensor('int64', new BigInt64Array(attentionMask.map(x => BigInt(x))), [1, maxLength]);
            
            return {
                inputTensor: inputTensor,
                attentionMask: attentionMaskTensor
            };
        }

        function postprocess(results, outputName) {
            console.log('Model outputs:', results);
            console.log('Output names:', Object.keys(results));
            
            // Get the output tensor
            let outputTensor = results[outputName];
            if (!outputTensor) {
                console.error('Output tensor not found:', outputName);
                // Try the first output if the specified one isn't found
                const firstOutputName = Object.keys(results)[0];
                console.log('Using first available output instead:', firstOutputName);
                outputTensor = results[firstOutputName];
            }
            
            // Extract data from the tensor
            const outputData = outputTensor.data;
            const outputShape = outputTensor.dims;
            
            console.log('Output shape:', outputShape);
            console.log('Output data:', Array.from(outputData).slice(0, 10));
            
            // Find the index with the highest probability
            let maxIndex = 0;
            let maxValue = outputData[0];
            
            for (let i = 1; i < outputData.length; i++) {
                if (outputData[i] > maxValue) {
                    maxValue = outputData[i];
                    maxIndex = i;
                }
            }
            
            // Apply softmax if needed to get probabilities
            const expValues = Array.from(outputData).map(val => Math.exp(val));
            const sumExp = expValues.reduce((acc, val) => acc + val, 0);
            const probabilities = expValues.map(val => val / sumExp);
            
            // Get the label for the prediction
            const predictedLabel = maxIndex < emotionLabels.length 
                ? emotionLabels[maxIndex] 
                : `Class ${maxIndex}`;
            
            return {
                label: predictedLabel,
                confidence: probabilities[maxIndex],
                allProbabilities: probabilities,
                allLabels: emotionLabels
            };
        }
    </script>

    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            text-align: center;
        }
        
        .input-section {
            margin-bottom: 20px;
        }
        
        textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 10px;
            font-family: inherit;
        }
        
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            text-align: center;
            cursor: pointer;
            border-radius: 4px;
            font-size: 16px;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        button:hover:not(:disabled) {
            background-color: #45a049;
        }
        
        .results-section {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #eee;
        }
        
        .prediction-result {
            margin-top: 10px;
        }
        
        .spinner {
            color: #666;
            font-style: italic;
        }
        
        .status-message {
            padding: 8px;
            margin: 10px 0;
            border-radius: 4px;
            text-align: center;
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
        }
        
        .status-message.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status-message.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
    </style>
</body>
</html>
