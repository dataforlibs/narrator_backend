<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emotion Detection with ONNX</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #2c3e50;
            text-align: center;
        }
        .input-area {
            margin-bottom: 20px;
        }
        #text-input {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            resize: vertical;
            min-height: 100px;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        .results {
            margin-top: 20px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9f9;
            display: none;
        }
        .emotion-bar {
            height: 25px;
            margin: 5px 0;
            display: flex;
            align-items: center;
        }
        .bar-label {
            width: 80px;
            font-weight: bold;
        }
        .bar-container {
            flex-grow: 1;
            height: 20px;
            background-color: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
        }
        .bar {
            height: 100%;
            background-color: #3498db;
            border-radius: 10px;
            transition: width 0.5s;
        }
        .bar-value {
            margin-left: 10px;
            width: 60px;
            text-align: right;
        }
        .predicted {
            background-color: #2ecc71;
        }
        .status-message {
            text-align: center;
            margin: 10px 0;
            font-style: italic;
            color: #7f8c8d;
        }
        #loading-status {
            display: none;
        }
        .emoji {
            font-size: 24px;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Emotion Detection</h1>
        <div id="loading-status" class="status-message">Loading model, please wait...</div>
        
        <div class="input-area">
            <textarea id="text-input" placeholder="Enter some text to analyze emotions...">I'm so happy to see you again after all these years!</textarea>
            <div style="margin-top: 10px; text-align: center;">
                <button id="analyze-btn" disabled>Analyze Emotions</button>
            </div>
        </div>
        
        <div id="results" class="results">
            <h2>Emotion Analysis Results</h2>
            <p id="predicted-emotion"></p>
            <div id="emotion-bars"></div>
        </div>
    </div>

    <!-- Load ONNX Runtime Web -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.14.0/dist/ort.min.js"></script>
    
    <script>
        // Configuration
        const MODEL_URL = 'emotion_model.onnx';
        const VOCAB_URL = 'emotion_tokenizer/vocab.json';
        const EMOTION_LABELS = ["anger", "disgust", "fear", "joy", "neutral", "sadness", "surprise"];
        const EMOTION_EMOJIS = {
            "anger": "😠",
            "disgust": "🤢",
            "fear": "😨",
            "joy": "😄",
            "neutral": "😐",
            "sadness": "😢",
            "surprise": "😲"
        };

        // Elements
        const textInput = document.getElementById('text-input');
        const analyzeBtn = document.getElementById('analyze-btn');
        const resultsDiv = document.getElementById('results');
        const predictedEmotion = document.getElementById('predicted-emotion');
        const emotionBars = document.getElementById('emotion-bars');
        const loadingStatus = document.getElementById('loading-status');

        // Application state
        let session = null;
        let vocab = null;
        let specialTokens = {
            CLS: 101,
            SEP: 102,
            PAD: 0,
            UNK: 100
        };

        // Initialize the application
        async function initialize() {
            loadingStatus.style.display = 'block';
            
            try {
                // Load model
                session = await ort.InferenceSession.create(MODEL_URL);
                
                // Load tokenizer vocabulary
                const response = await fetch(VOCAB_URL);
                if (!response.ok) {
                    throw new Error(`Failed to load vocab: ${response.statusText}`);
                }
                vocab = await response.json();
                
                analyzeBtn.disabled = false;
                loadingStatus.style.display = 'none';
                console.log("Model and tokenizer loaded successfully");
            } catch (error) {
                loadingStatus.textContent = `Error loading model: ${error.message}`;
                console.error("Initialization failed:", error);
            }
        }

        // Tokenize text for the model
        function tokenize(text, maxLength = 16) {
            // Basic implementation - would need to match your PyTorch tokenizer exactly
            // This is a simplified version and may not produce the same results
            
            // Convert to lowercase and split
            const tokens = text.toLowerCase().replace(/[^\w\s]/g, '').split(/\s+/);
            
            // Start with CLS token
            const inputIds = [specialTokens.CLS];
            
            // Add tokens
            for (const token of tokens) {
                if (token in vocab) {
                    inputIds.push(vocab[token]);
                } else {
                    // Try to handle unknown tokens
                    inputIds.push(specialTokens.UNK);
                }
                
                if (inputIds.length >= maxLength - 1) {
                    break;
                }
            }
            
            // Add SEP token
            inputIds.push(specialTokens.SEP);
            
            // Pad to max length
            while (inputIds.length < maxLength) {
                inputIds.push(specialTokens.PAD);
            }
            
            // Create attention mask (1 for real tokens, 0 for padding)
            const attentionMask = inputIds.map(id => id === specialTokens.PAD ? 0 : 1);
            
            return {
                inputIds: inputIds.slice(0, maxLength),
                attentionMask: attentionMask.slice(0, maxLength)
            };
        }

        // Softmax implementation
        function softmax(logits) {
            const maxLogit = Math.max(...logits);
            const expScores = logits.map(logit => Math.exp(logit - maxLogit));
            const expSum = expScores.reduce((sum, expScore) => sum + expScore, 0);
            return expScores.map(expScore => expScore / expSum);
        }

        // Run inference with the model
        async function predict(text) {
            if (!session) {
                throw new Error("Model not initialized");
            }

            try {
                // Tokenize text
                const tokenized = tokenize(text);
                
                // Create input tensors
                const inputIds = new ort.Tensor('int64', new BigInt64Array(tokenized.inputIds.map(id => BigInt(id))), [1, tokenized.inputIds.length]);
                const attentionMask = new ort.Tensor('int64', new BigInt64Array(tokenized.attentionMask.map(id => BigInt(id))), [1, tokenized.attentionMask.length]);
                
                // Run inference
                const feeds = { 
                    'input_ids': inputIds, 
                    'attention_mask': attentionMask 
                };
                
                const results = await session.run(feeds);
                const logits = results.logits.data;
                
                // Process the results (softmax)
                const probabilities = softmax(Array.from(logits));
                
                // Get the predicted class (highest probability)
                const predictedClassIndex = probabilities.indexOf(Math.max(...probabilities));
                
                // Return results in a structured format
                return {
                    predictedEmotion: EMOTION_LABELS[predictedClassIndex],
                    probabilities: EMOTION_LABELS.reduce((obj, label, index) => {
                        obj[label] = probabilities[index];
                        return obj;
                    }, {})
                };
            } catch (error) {
                console.error("Prediction failed:", error);
                throw error;
            }
        }

        // Update the UI with results
        function displayResults(result) {
            // Show results div
            resultsDiv.style.display = 'block';
            
            // Set predicted emotion text
            const emoji = EMOTION_EMOJIS[result.predictedEmotion];
            predictedEmotion.innerHTML = `<strong>Predicted emotion: ${emoji} ${result.predictedEmotion}</strong>`;
            
            // Clear previous bars
            emotionBars.innerHTML = '';
            
            // Create bars for each emotion
            EMOTION_LABELS.forEach(emotion => {
                const probability = result.probabilities[emotion];
                const percentage = Math.round(probability * 100);
                
                const emotionBar = document.createElement('div');
                emotionBar.className = 'emotion-bar';
                
                const barLabel = document.createElement('div');
                barLabel.className = 'bar-label';
                barLabel.textContent = `${EMOTION_EMOJIS[emotion]} ${emotion}`;
                
                const barContainer = document.createElement('div');
                barContainer.className = 'bar-container';
                
                const bar = document.createElement('div');
                bar.className = `bar ${emotion === result.predictedEmotion ? 'predicted' : ''}`;
                bar.style.width = `${percentage}%`;
                
                const barValue = document.createElement('div');
                barValue.className = 'bar-value';
                barValue.textContent = `${percentage}%`;
                
                barContainer.appendChild(bar);
                emotionBar.appendChild(barLabel);
                emotionBar.appendChild(barContainer);
                emotionBar.appendChild(barValue);
                
                emotionBars.appendChild(emotionBar);
            });
        }

        // Handle analyze button click
        analyzeBtn.addEventListener('click', async () => {
            const text = textInput.value.trim();
            
            if (!text) {
                alert('Please enter some text to analyze');
                return;
            }
            
            try {
                analyzeBtn.disabled = true;
                analyzeBtn.textContent = 'Analyzing...';
                
                const result = await predict(text);
                displayResults(result);
                
                analyzeBtn.textContent = 'Analyze Emotions';
                analyzeBtn.disabled = false;
            } catch (error) {
                console.error('Analysis failed:', error);
                alert('Analysis failed: ' + error.message);
                
                analyzeBtn.textContent = 'Analyze Emotions';
                analyzeBtn.disabled = false;
            }
        });

        // Initialize when the page loads
        document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>
</html>
